import streamlit as st
import pandas as pd
import plotly.express as px
import folium   # Renderizado del mapa
from streamlit_folium import st_folium
from datetime import datetime
from folium.plugins import FastMarkerCluster

# Configuraci칩n de la p치gina
st.set_page_config(
    page_title = "Sales Analytics Dashboard",
    layout="wide",
    initial_sidebar_state = "expanded"
)

# Funci칩n para la carga de datos
def load_data():
    """
    Cargar y combinar los conjuntos de datos referentes a
    1. Transacciones de ventas
    2. Cat치logo de productos
    3. Informaci칩n de clientes
    Retorna una tupla con los datos
    """
    transacciones = pd.read_csv('df_transacciones.csv', parse_dates=['fecha'],dtype={'producto_id':'string', 'cliente_id':'string'})
    productos = pd.read_csv('df_productos.csv', dtype={'cliente_id': 'string'})
    clientes = pd.read_csv('df_clientes.csv', dtype={'cliente_id': 'string'})

    datos_comb = pd.merge(transacciones, productos, on = 'producto_id', how='left')
    datos_comb = pd.merge(datos_comb, clientes, on='cliente_id', how='left')

    return datos_comb, clientes

# Carga inicial de datos
df, df_clientes = load_data()

# Barra lateral con los filtros interactivos
with st.sidebar:
    st.header("Filtros")

    # Selector de rango de fechas
    fecha_min = df['fecha'].min().date()
    fecha_max = df['fecha'].max().date()

    fechas_seleccionadas = st.date_input(
        label = "Rango de fechas",
        value = (fecha_min, fecha_max),
        min_value = fecha_min,
        max_value = fecha_max,
        help = "Selecciona el per칤odo a analizar"
    )

    # Selector de categor칤as
    categorias_disponibles = sorted(df['categoria'].unique())
    categorias_seleccionadas = st.multiselect(
        label = "Categor칤as de productos",
        options = categorias_disponibles,
        default = categorias_disponibles,
        help = "Filtra por categor칤as de productos"
    )

    # Filtro por segmento de clientes
    segmentos = sorted(df['segmento'].unique())
    segmentos_seleccionados = st.multiselect(
        label = "Segmentos de clientes",
        options = segmentos,
        default = segmentos,
        help = "Filtra por segmentos de clientes"
    )

# Aplicaci칩n de filtros
condicion_filtro = (
    (df['fecha'].dt.date >= fechas_seleccionadas[0]) &
    (df['fecha'].dt.date <= fechas_seleccionadas[1]) &
    (df['categoria'].isin(categorias_seleccionadas)) &
    (df['segmento'].isin(segmentos_seleccionados))
)

# Aplicar filtros
df_filtrado = df[condicion_filtro].copy()

# Secci칩n principal del dasboard, primero los kpis
st.title("Dashboard de Ventas")
st.markdown("""
    Visualizaci칩n interactiva de m칠tricas de ventas y distribuci칩n de clientes.
    Utiliza los filtros en la barra lateral para personalizar la vista.
""")

# KPIS Principales
st.header("M칠tricas clave")

# C치lculo de m칠tricas
ventas_totales = df_filtrado['total'].sum()
ventas_mensuales = df_filtrado.groupby(
    pd.Grouper(key='fecha', freq='ME')
)['total'].sum().mean()
clientes_unicos = df_filtrado['cliente_id'].nunique()

# C치lculo de tasa de retenci칩n
compras_por_cliente = df_filtrado['cliente_id'].value_counts()
tasa_retencion = (compras_por_cliente > 1).mean() * 100

# Mostras m칠tricas
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric(
        label = "Ventas totales",
        value = f"${ventas_totales:,.2f}",
        help = "Suma total de ventas en el per칤odo seleccionado"
    )

with col2:
    st.metric(
        label="Ventas Mensuales Promedio",
        value=f"${ventas_mensuales:,.2f}",
        help="Promedio de ventas por mes"
    )

with col3:
    st.metric(
        label="Clientes 칔nicos",
        value=f"{clientes_unicos:,}",
        help="N칰mero de clientes distintos con compras"
    )

with col4:
    st.metric(
        label="Tasa de Retenci칩n",
        value=f"{tasa_retencion:.1f}%",
        help="Porcentaje de clientes con m치s de una compra"
    )

# Gr치ficos de tendencias
st.header("Tendencia mensual de ventas")

datos_mensuales = df_filtrado.groupby(
    pd.Grouper(key='fecha', freq='ME')
).agg({
    'total':'sum',
    'transaccion_id':'count'
}).rename(columns={
    'transaccion_id':'numero_transacciones'
}).reset_index()

fig = px.area(
    datos_mensuales,
    x='fecha',
    y='total',
    title='Evoluci칩n mensual de ventas',
    labels={
        'fecha': 'Mes',
        'total': 'Ventas ($)'
    },
    hover_data=['numero_transacciones']
)

fig.update_traces(
    line=dict(width=2.5),
    marker=dict(size=8),
    fill='tozeroy',
    fillcolor='rgba(100, 200, 150, 0.2)'
)

fig.update_layout(
    xaxis_title="Mes",
    yaxis_title="Ventas ($)",
    hovermode="x unified"
)

# Mostrar gr치fico
st.plotly_chart(fig, use_container_width = True)


# Mapa de Distribuci칩n Geogr치fica con st_folium


# Verificaci칩n y limpieza de datos (igual que antes)
df_clientes_geo = df_clientes.copy()
st.header("Distribuci칩n Geogr치fica de Clientes")

# Crear mapa base
m = folium.Map(location=[df_clientes_geo['latitud'].mean(), df_clientes_geo['longitud'].mean()],
               zoom_start=6,
               tiles="cartodbpositron")

# Usar FastMarkerCluster para mejor rendimiento
FastMarkerCluster(
    data=df_clientes_geo[['latitud', 'longitud']].values.tolist(),
    name="Clientes",
    overlay=True,
    control=True
).add_to(m)

# A침adir control de capas
folium.LayerControl().add_to(m)

# Mostrar el mapa
st_data = st_folium(
    m,
    width=1200,
    height=600,
    returned_objects=[]
)

# Informaci칩n adicional debajo del mapa
st.write(f"Total clientes mostrados: {len(df_clientes_geo):,}")
st.caption("Zoom in/out para ver detalles. Haz clic en los marcadores para m치s informaci칩n.")
# --------------------------------------------------
# An치lisis por Categor칤a
# --------------------------------------------------
st.header("游닍 Ventas por Categor칤a")

# Dise침o de dos columnas
col_izq, col_der = st.columns(2)

with col_izq:
    # Gr치fico de torta por categor칤a
    ventas_por_categoria = df_filtrado.groupby('categoria')['total'].sum().reset_index()

    fig_torta = px.pie(
        ventas_por_categoria,
        names='categoria',
        values='total',
        title='Distribuci칩n de Ventas por Categor칤a',
        hole=0.3,  # Donut chart
        color_discrete_sequence=px.colors.qualitative.Pastel
    )

    st.plotly_chart(fig_torta, use_container_width=True)

with col_der:
    # Gr치fico de barras por categor칤a
    fig_barras = px.bar(
        ventas_por_categoria.sort_values('total', ascending=False),
        x='categoria',
        y='total',
        title='Ventas por Categor칤a (Ordenadas)',
        labels={'total': 'Monto de Ventas ($)'},
        color='categoria',
        color_discrete_sequence=px.colors.qualitative.Pastel
    )

    fig_barras.update_layout(showlegend=False)
    st.plotly_chart(fig_barras, use_container_width=True)

# --------------------------------------------------
# Explorador de Datos
# --------------------------------------------------
st.header("游댌 Explorador de Datos")

# Mostrar datos filtrados con configuraci칩n de columnas
st.dataframe(
    df_filtrado.sort_values('fecha', ascending=False),
    column_config={
        "fecha": "Fecha",
        "cliente_id": "ID Cliente",
        "producto_id": "ID Producto",
        "nombre": "Nombre Producto",
        "categoria": "Categor칤a",
        "cantidad": st.column_config.NumberColumn(
            "Cantidad",
            format="%d"  # Formato como entero
        ),
        "total": st.column_config.NumberColumn(
            "Monto",
            format="$%.2f"  # Formato monetario
        ),
        "segmento": "Segmento"
    },
    hide_index=True,  # Ocultar 칤ndice
    use_container_width=True,
    height=400  # Altura fija para el dataframe
)

# --------------------------------------------------
# Pie de p치gina
# --------------------------------------------------
st.markdown("---")
st.markdown(
    """
    **Funcionalidades del Tablero:**
    - Filtrado por rango de fechas
    - C치lculo din치mico de m칠tricas clave
    - Visualizaci칩n geogr치fica de clientes
    - An치lisis por categor칤as de productos
    - Exploraci칩n de datos crudos

    *칔ltima actualizaci칩n de datos: {}*
    """.format(datetime.now().strftime("%Y-%m-%d"))
)